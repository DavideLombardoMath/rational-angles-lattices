/*
Helper functions to handle lattices:
- decide if two lattices are homothetic
- compute tau from a solution (a,b,c,d,x,y,z)
- when ab=cd, also determine if such
  a solution gives rise to a geometrically
  valid configuration
- list rational angles in a given space
- compute the "type" of a space
*/

load "TracePoly.m";

/*
Test if the lattices generated by
tau1, tau2 are homothetic.
This is equivalent to the existence
of a Moebius transformation with
rational coefficients bringing
tau1 to tau2, and in turn this is
equivalent to the fact that
1, tau1, tau2, tau1*tau2 are
Q-linearly dependent
*/
function HomotheticLattices(tau1, tau2)
	if Parent(tau1) ne Parent(tau2) then
		error "The two taus do not live in the same number field";
	end if;
	K := Parent(tau1);
	V, map := KSpace(K, Rationals());
	v1 := map(tau1*tau2);
	v2 := map(tau1);
	v3 := map(tau2);
	v4 := map(K!1);
	W := sub<V | [v1,v2,v3,v4]>;
	return Dimension(W) le 3;
end function;

/*
Given a solution a,b,c,d,x,y,z to
the (2)+(2)+(2) equation, returns
the corresponding value of tau
and the minimal polynomial of tau
over Q.
When ab-cd is nonzero, there is only
one value of tau corresponding to
the solution (a,b,c,d,x,y,z), and
it necessarily lies in the same
cyclotomic field as x,y,z. When
ab=cd, however, tau may lie in
a quadratic extension of Q(x,y,z)
In this case, several additional
information are printed, and both
roots of the quadratic equations are
returned, together with the corresponding
minimal polynomials
*/
function TauFromSolution(a,b,c,d,x,y,z)
	q := a*b-c*d;
	if q ne 0 then		// in this case tau is a rational function of a,b,c,d,x,y,z
		tau := (c*d-a*b)*x*(y-1)*(z-1) / ( a*(y-x)*(z-1) + b*(x*y-1)*(z-1) - c*(z-x)*(y-1) - d*(x*z-1)*(y-1) );
		return [tau], [MinimalPolynomial(tau)];	
	end if;

	/* Otherwise, tau satisfies two proportional quadratic
	equations. We construct both equations and check
	that they are indeed proportional */
	K := Parent(x);
	R<tau> := PolynomialRing(K);
	f1 := tau^2 * (y-1) + tau*( a*(y-x) + b*(x*y-1) ) + a*b*x*(y-1);
	f2 := tau^2 * (z-1) + tau*( c*(z-x) + d*(x*z-1) ) + c*d*x*(z-1);
	if (z-1)*( a*(y-x) + b*(x*y-1) ) ne (y-1) * ( c*(z-x) + d*(x*z-1) ) then
		error "The two quadratic equations are not proportional";
	end if;

	/* Even though there is no automatic guarantee that
	tau lies in Q(x,y,z), this can still happen by
	accident. If it happens, then f1 is reducible over K,
	and both possible values of tau lie in K. Otherwise,
	we need to work in a quadratic extension F of K.
	In case F is itself an abelian extension of Q,
	we also compute and output its conductor. */
	if IsIrreducible(f1) then
		F := NumberField(f1);
		AbF := AbsoluteField(F);
		AbF := OptimisedRepresentation(AbF);
		"Tau does not lie in the same cyclotomic field as x,y,z";
		if IsAbelian(AbF) then
			"Tau lies in a cyclotomic extension. Conductor:", Conductor(MaximalAbelianSubfield(AbF));
		end if;
		rts := Roots(ChangeRing(f1,AbF));
	else
		rts := Roots(f1);
	end if;
	rts := [ r[1] : r in rts ];
	return rts, [MinimalPolynomial(r) : r in rts];
end function;

/*
The next two functions are similar. Given a list of irreducible
polynomials with rational coefficients, we construct a common
splitting field for all the input polynomials, and consider
the lattices V=<1,tau> for tau varying among the roots of
any of the given polynomials. Using the function
HomotheticLattices, we eliminate redundant (homothetic)
lattices, and return a non-redundant list of taus (chosen
among the roots of the given polynomials) that generate
a representative lattice from each homothety class.
Whenever possible, we work (and print the output) 
in a cyclotomic field.
*/
function DistinctLatticesCyclotomic( ListMinimalPolynomials, n )
	Lattices := [];
	PrunedList := { p : p in ListMinimalPolynomials };
	PrunedList := [p : p in PrunedList];
	TotalPoly := &* PrunedList;
	K<zetan> := CyclotomicField(n);
	"Printing output in the", n,"th cyclotomic field";
	rts := Roots(ChangeRing(TotalPoly,K));
	rts := [r[1] : r in rts];
	for tau in rts do
		test := true;
		for t in Lattices do
			test := test and not HomotheticLattices(t,tau);
		end for;
		if test then
			Append(~Lattices, tau);
		end if;
	end for;
	return Lattices;
end function;



function DistinctLattices( ListMinimalPolynomials )
	Lattices := [];
	PrunedList := { p : p in ListMinimalPolynomials };
	PrunedList := [p : p in PrunedList];
	TotalPoly := &* PrunedList;
	K := SplittingField(TotalPoly);
	K := OptimisedRepresentation(K);
	if IsAbelian(K) then
		cond := Generators(Conductor(MaximalAbelianSubfield(K)))[1][1];
		return DistinctLatticesCyclotomic(ListMinimalPolynomials, Integers()!cond);
	end if;
	rts := Roots(ChangeRing(TotalPoly,K));
	rts := [r[1] : r in rts];
	for tau in rts do
		test := true;
		for t in Lattices do
			test := test and not HomotheticLattices(t,tau);
		end for;
		if test then
			Append(~Lattices, tau);
		end if;
	end for;
	return Lattices;
end function;

/*
Yet another variant of the DistinctLattices
function. In this case we take a list of
algebraic elements already embedded in a
number field, together with the roots of
unity representing their (squared) angles 
with respect to the real axis. This version
is used for the ab=cd case, when complex
conjugation and the Galois action are
less straightforward.
*/
function DistinctLatticesabcd(L)
	ResultLattices := [];
	for l in L do
		test := true;
		for lat in ResultLattices do
			if test and HomotheticLattices(l[1], lat[1]) then
				test := false;
			end if;
		end for;
		if test then
			Append(~ResultLattices, l);
		end if;
	end for;
	return ResultLattices;
end function;

/*
Helper function to manage lists of angles and corresponding amplitudes
Appends an angle (given as a pair NewAngle=(tau+a, tau+b)) with amplitude
NewAmplitude to the already existing list. If tau+a or tau+b is already
part of an existing angle, the lists and amplitudes are merged
accordingly.
*/
function AppendAngle(RationalTuples, Amplitudes, NewAngle, NewAmplitude)
	for i in [1..#RationalTuples] do
		if #(RationalTuples[i] meet NewAngle) gt 0 then
			RationalTuples[i] := RationalTuples[i] join NewAngle;
			Amplitudes[i] := Amplitudes[i] join {NewAmplitude};
			
			// it is possible that adding a new angle will merge two
			// previously separate groups of angles: for example,
			// adding (tau+1,tau+2) to {(tau, tau+1), (tau+2,tau+3)}
			// should produce {(tau, tau+1, tau+2, tau+3)}
			while #RationalTuples gt 1 and #(RationalTuples[1] meet RationalTuples[2]) gt 0 do
				RationalTuples[1] := RationalTuples[1] join RationalTuples[2];
				Amplitudes[1] := Amplitudes[1] join Amplitudes[2];
				Remove(~RationalTuples,2);
				Remove(~Amplitudes,2);
			end while;

			return RationalTuples, Amplitudes;
		end if;
	end for;
	return RationalTuples cat [NewAngle], Amplitudes cat [{NewAmplitude}];
end function;

/*
Returns a list of all rational angles in a given lattice
The output is a list of pairs {lattice elements}, {amplitudes},
where the lattice elements are either 1 or of the form tau+a
for some rational number a, and they all form rational angles
among themselves. The corresponding (squared) amplitudes are
given in the second list as positive integers (to be interpreted
as the exponents of a root of unity zeta_n).
The parameter rootx describes the squared amplitude of
the angle between 1 and tau, so that taubar = tau/rootx.
If this parameter is omitted, the function assumes that
tau lies in a cyclotomic field: indeed, in this case
complex conjugation is well-defined, so that x can
be recovered from tau.
*/
function AllAffineAnglesInGivenLattice(tau : rootx := 1)
	K := Parent(tau);
	if rootx eq 1 then
		h := hom<K->K | K.1^(-1)>;	// complex conjugation is well-defined on a cyclotomic field
		x := tau/h(tau);		// x is the ratio of tau and its complex conjugate
	else
		x := K!rootx;
	end if;
	GU, map := TorsionUnitGroup(K);
	R<a,b> := PolynomialRing(K,2);
	RR<A,B> := PolynomialRing(Rationals(),2);
	T<Tau> := PolynomialRing(Rationals());

	RationalTuples := [];
	Amplitudes := [];

	for i in [1..(#GU-1)] do	// the possible squared amplitudes
		eqn := (tau/x + a) * (tau + b) - map(GU.1)^i * (tau + a) * (tau/x + b);		// the equation for a rational angle of given squared amplitude
		eqs := [RR!TracePolynomial(eqn*z) : z in Basis(K) ];
		S := Scheme(AffineSpace(RR), eqs);
		ic := IrreducibleComponents(ReducedSubscheme(S));

		for comp in ic do
			assert Dimension(comp) eq 0;						// there are only finitely many angles of a given amplitude
			sols := RationalPoints(comp);						// so we can list them (notice that we do not look at
												// arbitrary lattice elements of the form m*tau+n,
												// but only at those of the form tau+rational number)
			if #sols gt 0 then							// If there are angles of the given amplitude,
				for sol in sols do						// we append them to the list of angles already found
					RationalTuples, Amplitudes := AppendAngle(RationalTuples, Amplitudes, {Tau+sol[1],Tau+sol[2]}, i);
				end for;
			end if;
		end for;

		eqn := (tau + b) - map(GU.1)^i * (tau/x + b);					// here we handle angles formed by tau+b with
		eqs := [RR!TracePolynomial(eqn*z) : z in Basis(K) ];				// 1, i.e., with the real axis, in the same
		S := Scheme(AffineSpace(RR), eqs cat [A]);					// way as the general case
		ic := IrreducibleComponents(ReducedSubscheme(S));

		for comp in ic do
			assert Dimension(comp) eq 0;
			sols := RationalPoints(comp);
			if #sols gt 0 then
				for sol in sols do
					RationalTuples, Amplitudes := AppendAngle(RationalTuples, Amplitudes, {1, Tau+sol[2]}, i);
				end for;
			end if;
		end for;


	end for;

	/* Amplitudes are stable under x --> n-x
	We impose this symmetry manually,
	because our handling of the angles
	with the real axis is not symmetric:
	we have only considered ratios (tau + b)/1,
	disregarding the ratios 1/(tau+b) */
	for i in [1..#Amplitudes] do
		Amplitudes[i] := Amplitudes[i] join {#GU-j : j in Amplitudes[i]};
	end for;

	return RationalTuples, Amplitudes;
end function;

/*
Returns the "type" of a lattice,
i.e. a sequence of positive integers
describing the maximal sets of adjacent
rational angles in the lattice.
If the parameter xroot is not specified,
the generator tau is assumed to
lie in a cyclotomic field
*/
function TypeOfSpace(tau : rootx := 1)
	return [#P : P in AllAffineAnglesInGivenLattice(tau : rootx := rootx)];
end function;

function MergeFieldsList(L)
	while #L ge 2 do
		L[1] := Compositum(L[1], L[2]);
		Remove(~L, 2);
	end while;
	return L[1];
end function;

/* Given a solution to the (2)+(2)+(2) equation
with ab=cd, this function takes all the Galois
conjugates, and for each of them checks whether
the discriminant of the quadratic equation 
giving |tau| is a positive real number.
If it is, it adds the lattices thus found 
to the list AllTaus. At the end, we prune 
the list from duplicates. We keep track 
along the way of the root of unity x such
that taubar = tau/x, and display additional
information about the lattices found.
*/
function DescribeGeometricRealisations(a,b,c,d,x,y,z)
	K := Parent(x);
	n := Conductor(K);
	invs := [i : i in [1..n] | GCD(i,n) eq 1];
	AllTaus := [* *];
	for auto in Automorphisms(K) do			// we consider each Galois
							// conjugate invidually

		autox := auto(x);			// Apply the Galois automorphism
		autoy := auto(y);			// simultaneously to all three
		autoz := auto(z);			// roots of unity
		discriminant := ( a*(autoy-autox) + b*(autox*autoy-1) )^2 / (autox*(autoy-1)^2) - 4*(a*b);	// the discriminant of the equation for |tau|
		discR := Conjugates(discriminant)[1];								// the image of discriminant under the standard
														// embedding of the cyclotomic field into C

		assert Im(discR) lt 10^(-100);
		if Re(discR) gt 0 then
			"Applying the automorphism sending zeta_n to", auto(K.1), "leads to a geometrically valid configuration";
			"The corresponding values of tau satisfy the equation";
			T<tau> := PolynomialRing(K);
			tau^2 * (autoy-1) + tau*( a*(autoy-autox) + b*(autox*autoy-1) ) + a*b*autox*(autoy-1);
			taus := TauFromSolution(a,b,c,d,autox,autoy,autoz);
			AllTaus := AllTaus cat [* [* tau, autox *] : tau in taus *];
			if HomotheticLattices(taus[1], taus[2]) then
				"The lattices corresponding to the two different values of tau are homothetic";
			else
				"The lattices corresponding to the two different values of tau are not homothetic";
			end if;
		end if;
	end for;
	if #AllTaus eq 0 then
		return [];
	end if;

	CommonField := MergeFieldsList( [ NormalClosure(Parent(tau[1])) : tau in AllTaus ] );
	AllTaus := [ [ CommonField!tau[1], CommonField!tau[2] ] : tau in AllTaus];

	for i in [1..#AllTaus] do
		for j in [i+1..#AllTaus] do
			if HomotheticLattices( AllTaus[i][1], AllTaus[j][1] ) then
				"Lattices number", i, "and", j, "are homothetic";
			end if;
		end for;
	end for;

	GeometricLattices := DistinctLatticesabcd(AllTaus);

	return GeometricLattices;
end function;


/*
Bound the degree of Q(x,y,z) over its subfields Q(x,y), Q(x,z) and Q(y,z).
This is used to slightly reduce the number of triples of roots of unity
that we need to consider. The upshot is that each root of unity always lies
in an at most quadratic extension of the field generated by the other two:
this follows from Equation (2) in the paper, which is quadratic in each of
x, y, z, provided that (when seen as a polynomial in x, say, with y and z
fixed) not all coefficients of P vanish. This non-vanishing is what we check
in this file.
*/

SetLogFile("Degree.out");
function AppendSubscheme(ListOfSubschemes, SchemeToAppend)
	for S in ListOfSubschemes do
		if DefiningIdeal(S) eq DefiningIdeal(SchemeToAppend) then
			return ListOfSubschemes;
		end if;
	end for;
	return ListOfSubschemes join { SchemeToAppend };
end function;

function CheckIrrelevantSubscheme(S)
	I := DefiningIdeal(S);
	R := Parent(Generators(I)[1]);
	if R.1-R.2 in I then				// any solution with a=b should be discarded
		return true;
	end if;
	if R.3-R.4 in I then				// any solution with c=d should be discarded
		return true;
	end if;
	if R.5-1 in I or R.6-1 in I then		// any solution where a root of unity is 1 should be discarded
		return true;
	end if;
	if R.5 in I or R.6 in I then			// any solution where a root of unity is 1 should be discarded
		return true;
	end if;
	if (R.1-R.3 in I and R.2-R.4 in I) or (R.1-R.4 in I and R.2-R.3 in I) then		// solutions with {a,b}={c,d} should be discarded
		return true;
	end if;
	return false;
end function;

function FieldGeneratedByOneRootOfUnityOverTheOthers(whichRoot)

	// Construct the ring of polynomials in one variable,
	// selected through the parameter whichRoot, with
	// coefficients in the ring of polynomials in the
	// remaining 6 variables
	if whichRoot eq "x" then
		R<a,b,c,d,y,z> := PolynomialRing(Rationals(), 6);
		S<x> := PolynomialRing(R);
	end if;
	if whichRoot eq "y" then
		R<a,b,c,d,x,z> := PolynomialRing(Rationals(), 6);
		S<y> := PolynomialRing(R);
	end if;
	if whichRoot eq "z" then
		R<a,b,c,d,x,y> := PolynomialRing(Rationals(), 6);
		S<z> := PolynomialRing(R);
	end if;



	// Now construct the 2+2+2 equation,
	// considered as a polynomial in the variable
	// whichRoot with coefficients given
	// by polynomials in the other variables
	monomials := [x^2 * y^2 * z^2, 1, 
	x^2 * y^2 * z, z,
	x^2 * y * z^2, y,
	x * y^2 * z^2, x,
	x^2 * y^2, z^2,
	x^2 * y*z, y * z,
	x^2 * z^2, y^2,
	x * y^2 * z, x * z,
	x * y * z^2, x * y,
	y^2 * z^2, x^2,
	x^2 * y, y * z^2,
	x^2 * z, y^2 * z,
	x * y^2, x * z^2,
	x * y * z
	];

	coefficients := [ -b*(a-c)*(b-d)*d, -b*(a-c)*(b-d)*d,
	b*(a*b*c + a*b*d - 2*a*c*d - 2*b*c*d + c^2*d + c*d^2), b*(a*b*c + a*b*d - 2*a*c*d - 2*b*c*d + c^2*d + c*d^2),
	d*(a^2*b + a*b^2 - 2*a*b*c - 2*a*b*d + a*c*d + b*c*d), d*(a^2*b + a*b^2 - 2*a*b*c - 2*a*b*d + a*c*d + b*c*d),
	(a - c)*(b - d)*(a*b + c*d), (a - c)*(b - d)*(a*b + c*d),
	-b*(b - c)*c*(a - d), -b*(b - c)*c*(a - d),
	-a^2*b*c - a*b^2*c - a^2*b*d - a*b^2*d + 8*a*b*c*d - a*c^2*d - b*c^2*d - a*c*d^2 - b*c*d^2, -a^2*b*c - a*b^2*c - a^2*b*d - a*b^2*d + 8*a*b*c*d - a*c^2*d - b*c^2*d - a*c*d^2 - b*c*d^2,
	-a*(b - c)*(a - d)*d, -a*(b - c)*(a - d)*d,
	-2 * a^2 * b^2 + a^2 * b * c + a * b^2 * c - 2 * a * b * c^2 + a^2 * b * d + a * b^2 * d + a * c^2 * d + b * c^2 * d - 2 * a * b * d^2 + a * c * d^2 + b * c * d^2 - 2 * c^2 * d^2, -2 * a^2 * b^2 + a^2 * b * c + a * b^2 * c - 2 * a * b * c^2 + a^2 * b * d + a * b^2 * d + a * c^2 * d + b * c^2 * d - 2 * a * b * d^2 + a * c * d^2 + b * c * d^2 - 2 * c^2 * d^2,
	-2*a^2*b^2 + a^2*b*c + a*b^2*c + a^2*b*d + a*b^2*d - 2*a^2*c*d-2*b^2*c*d + a*c^2*d + b*c^2*d + a*c*d^2 + b*c*d^2 - 2*c^2*d^2, -2*a^2*b^2 + a^2*b*c + a*b^2*c + a^2*b*d + a*b^2*d - 2*a^2*c*d-2*b^2*c*d + a*c^2*d + b*c^2*d + a*c*d^2 + b*c*d^2 - 2*c^2*d^2,
	-a*(a - c)*c*(b - d), -a*(a - c)*c*(b - d),
	c*(a^2*b + a*b^2 - 2*a*b*c - 2*a*b*d + a*c*d + b*c*d), c*(a^2*b + a*b^2 - 2*a*b*c - 2*a*b*d + a*c*d + b*c*d),
	a*(a*b*c + a*b*d - 2*a*c*d - 2*b*c*d + c^2*d + c*d^2), a*(a*b*c + a*b*d - 2*a*c*d - 2*b*c*d + c^2*d + c*d^2),
	(b - c)*(a - d)*(a*b + c*d), (b - c)*(a - d)*(a*b + c*d),
	2*(2*a^2*b^2 - a^2*b*c - a*b^2*c + 2*a*b*c^2 - a^2*b*d - a*b^2*d + 2*a^2*c*d - 4*a*b*c*d+2*b^2*c*d - a*c^2*d - b*c^2*d + 2*a*b*d^2 - a*c*d^2 - b*c*d^2 + 2*c^2*d^2)];

	poly := &+[ monomials[i]*coefficients[i] : i in [1..#monomials] ];

	// poly is a polynomial of degree 2
	// in the variable whichRoot
	// If its coefficients do not all vanish,
	// then (for any solution in Qbar
	// to the equation poly = 0) 
	// the variable whichRoot lies in an at most
	// quadratic extension of the field
	// generated by the other two roots of unity.
	
	// We now determine the solutions
	// that lead to all coefficients being 0
	// We extract the coefficients (polynomials
	// in the other six variables) of poly
	// and use them to construct a variety
	// that gives the conditions on the other
	// six variables for this to happen.
	coefs := Coefficients(poly);
	AllIrreducibleComponents := {};

	// To help MAGMA with the computation we proceed as follows.
	// We first factor each coefficient, and consider the various
	// schemes defined by the vanishing of one irreducible factor
	// for each coefficient. The union of these schemes is
	// the scheme we are actually interested in, namely, the locus
	// where all the cofficients coefs vanish.

	// It turns out that the Groebner bases computations for these
	// schemes take too long. We simplify them as follows:
	// let I be the ideal defining the scheme we want to study
	// and let IProj1, IProj2 be the elimination ideals obtained
	// by intersecting I with the subring of R
	// given by polynomials where one of the two roots of unity
	// (different from whichRoot) does not appear. 
	// Then I contains IProj1 and IProj2, so the affine variety
	// defined by I is contained in the intersection of the
	// varieties defined by IProj1 and IProj2 (geometrically,
	// we are projecting down to a 5-dimensional affine space
	// and then taking the inverse image of the projection:
	// this certainly enlarges the variety under consideration).
	// The intersection S2 = V(IProj1) \cap V(IProj2) turns out
	// to be easier to handle computationally.
	// We consider its underlying reduced variety S2R
	// and compute its irreducible components.
	// Finally, we discard those that do not have
	// geometric sense for our problem.
	fact1 := Factorisation(coefs[1]);
	fact2 := Factorisation(coefs[2]);
	fact3 := Factorisation(coefs[3]);
	for f1 in fact1 do
	for f2 in fact2 do
	for f3 in fact3 do
		I := ideal<R | [f1[1], f2[1], f3[1]]>;
		IProj1 := EliminationIdeal(I, {a,b,c,d,R.5});
		IProj2 := EliminationIdeal(I, {a,b,c,d,R.6});
		S2 := Scheme(AffineSpace(R), Generators(IProj1) cat Generators(IProj2));
		S2R := ReducedSubscheme(S2);
		for c in IrreducibleComponents(S2R) do
			AllIrreducibleComponents := AppendSubscheme(AllIrreducibleComponents,c);
		end for;
	end for;
	end for;
	end for;

	return { c : c in AllIrreducibleComponents | not CheckIrrelevantSubscheme(c) };
end function;

"Consider the equation f = 0 as a polynomial in x. Conditions for the vanishing of all coefficients:";
FieldGeneratedByOneRootOfUnityOverTheOthers("x");
"Consider the equation f = 0 as a polynomial in y. Conditions for the vanishing of all coefficients:";
FieldGeneratedByOneRootOfUnityOverTheOthers("y");
"Consider the equation f = 0 as a polynomial in z. Conditions for the vanishing of all coefficients:";
FieldGeneratedByOneRootOfUnityOverTheOthers("z");

exit;
